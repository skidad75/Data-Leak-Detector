import streamlit as st
import socket
import re
import concurrent.futures
from urllib.parse import urlparse
import pydeck as pdk
import requests
from safety import safety

def is_valid_domain(domain):
    pattern = r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$"
    return re.match(pattern, domain) is not None

def is_valid_ip(ip):
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

def extract_domain(url):
    parsed_url = urlparse(url)
    domain = parsed_url.netloc or parsed_url.path
    domain = domain.split(':')[0]  # Remove port if present
    return domain.lower()

def check_port(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, port))
    sock.close()
    return port if result == 0 else None

def get_service_name(port):
    common_ports = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
        110: "POP3", 143: "IMAP", 443: "HTTPS", 445: "SMB", 3306: "MySQL",
        3389: "RDP", 5432: "PostgreSQL", 8080: "HTTP-Proxy"
    }
    return common_ports.get(port, "Unknown")

def perform_vulnerability_scan(target):
    try:
        ip = socket.gethostbyname(target)
    except socket.gaierror:
        st.error(f"Unable to resolve hostname: {target}")
        return None

    common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3306, 3389, 5432, 8080]
    open_ports = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_to_port = {executor.submit(check_port, ip, port): port for port in common_ports}
        for future in concurrent.futures.as_completed(future_to_port):
            port = future.result()
            if port:
                open_ports.append(port)

    vulnerabilities = []
    for port in open_ports:
        service = get_service_name(port)
        vulnerabilities.append({
            'port': port,
            'service': service,
            'potential_vulnerabilities': f"Open {service} port may be vulnerable if not properly secured."
        })

    return vulnerabilities

def check_dependencies():
    try:
        vulns = safety.check()
        return vulns
    except Exception as e:
        st.error(f"Error running safety check: {e}")
        return None

def get_ip_location(ip):
    try:
        response = requests.get(f"https://ipapi.co/{ip}/json/").json()
        return response.get("latitude"), response.get("longitude")
    except:
        return None, None

st.title("Vulnerability Scanner")

st.warning("⚠️ This tool is for educational purposes only. Do not use on systems you don't own or have explicit permission to test.")

scan_type = st.radio("Select scan type:", ["Network Scan", "Dependency Check"])

if scan_type == "Network Scan":
    target = st.text_input("Enter a domain or IP address to scan:")

    if st.button("Scan for Vulnerabilities"):
        if target:
            target = extract_domain(target)
            
            if is_valid_domain(target) or is_valid_ip(target):
                with st.spinner("Scanning for vulnerabilities... This may take a few minutes."):
                    vulnerabilities = perform_vulnerability_scan(target)
                    
                    if vulnerabilities:
                        st.subheader("Scan Results")
                        for vuln in vulnerabilities:
                            st.write(f"Port: {vuln['port']}")
                            st.write(f"Service: {vuln['service']}")
                            st.write(f"Potential Vulnerabilities: {vuln['potential_vulnerabilities']}")
                            st.write("---")
                        
                        # Get location of the IP and display on map
                        ip = socket.gethostbyname(target)
                        lat, lon = get_ip_location(ip)
                        if lat and lon:
                            st.subheader("Target Location")
                            map_data = pdk.Layer(
                                "ScatterplotLayer",
                                data=[{"position": [lon, lat], "color": [255, 0, 0, 160], "radius": 100}],
                                get_position="position",
                                get_color="color",
                                get_radius="radius",
                            )
                            view_state = pdk.ViewState(latitude=lat, longitude=lon, zoom=4)
                            st.pydeck_chart(pdk.Deck(layers=[map_data], initial_view_state=view_state))
                        else:
                            st.info("Unable to determine the location of the target.")
                    else:
                        st.info("No open ports found or unable to complete the scan.")
            else:
                st.error("Invalid domain or IP address. Please enter a valid target.")
        else:
            st.error("Please enter a domain or IP address to scan.")

elif scan_type == "Dependency Check":
    if st.button("Check Dependencies"):
        with st.spinner("Checking dependencies for vulnerabilities..."):
            vulnerabilities = check_dependencies()
            if vulnerabilities:
                st.subheader("Vulnerability Report")
                for vuln in vulnerabilities:
                    st.write(f"Package: {vuln.package_name}")
                    st.write(f"Installed Version: {vuln.installed_version}")
                    st.write(f"Vulnerable Versions: {vuln.vulnerable_spec}")
                    st.write(f"CVE: {vuln.vulnerability_id}")
                    st.write(f"Severity: {vuln.severity}")
                    st.write(f"Advisory: {vuln.advisory}")
                    st.write("---")
            else:
                st.info("No vulnerabilities found in dependencies.")

st.sidebar.warning("Note: This tool provides a basic vulnerability assessment. Always ensure you have permission to scan systems and use this information responsibly.")