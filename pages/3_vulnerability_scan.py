import streamlit as st
import socket
import re
import concurrent.futures
from urllib.parse import urlparse
import pydeck as pdk
import requests
import time

def is_valid_ip(ip):
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

class PortScan:
    def __init__(self, target, port_num):
        self.target = target
        self.port_num = port_num
        self.banners = []
        self.open_ports = []
        self.start_time = time.time()
        self.time_limit = 60  # 1 minute time limit

    def scan(self, progress_bar):
        with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
            futures = [executor.submit(self.scan_port, port) for port in range(1, self.port_num + 1)]
            for i, future in enumerate(concurrent.futures.as_completed(futures)):
                if time.time() - self.start_time > self.time_limit:
                    break
                progress_bar.progress((i + 1) / self.port_num)

    def check_ip(self):
        if is_valid_ip(self.target):
            return self.target
        else:
            return socket.gethostbyname(self.target)

    def scan_port(self, port):
        if time.time() - self.start_time > self.time_limit:
            return
        try:
            converted_ip = self.check_ip()
            sock = socket.socket()
            sock.settimeout(0.5)
            result = sock.connect_ex((converted_ip, port))
            if result == 0:
                self.open_ports.append(port)
                try:
                    banner = sock.recv(1024).decode().strip('\n').strip('\r')
                    self.banners.append(banner)
                except:
                    self.banners.append(' ')
            sock.close()
        except:
            pass

def is_valid_domain(domain):
    pattern = r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$"
    return re.match(pattern, domain) is not None

def extract_domain(url):
    parsed_url = urlparse(url)
    domain = parsed_url.netloc or parsed_url.path
    domain = domain.split(':')[0]  # Remove port if present
    return domain.lower()

def get_service_name(port):
    common_ports = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
        110: "POP3", 143: "IMAP", 443: "HTTPS", 445: "SMB", 3306: "MySQL",
        3389: "RDP", 5432: "PostgreSQL", 8080: "HTTP-Proxy"
    }
    return common_ports.get(port, "Unknown")

def perform_vulnerability_scan(target, max_port):
    scanner = PortScan(target, max_port)
    progress_bar = st.progress(0)
    scanner.scan(progress_bar)
    progress_bar.empty()

    vulnerabilities = []
    for i, port in enumerate(scanner.open_ports):
        service = get_service_name(port)
        banner = scanner.banners[i] if i < len(scanner.banners) else "No banner"
        vulnerabilities.append({
            'port': port,
            'service': service,
            'banner': banner,
            'potential_vulnerabilities': f"Open {service} port may be vulnerable if not properly secured."
        })

    return vulnerabilities

def get_ip_location(ip):
    try:
        response = requests.get(f"https://ipapi.co/{ip}/json/").json()
        return response.get("latitude"), response.get("longitude")
    except:
        return None, None

st.title("Vulnerability Scanner")

st.warning("⚠️ This tool is for educational purposes only. Do not use on systems you don't own or have explicit permission to test.")

target = st.text_input("Enter a domain or IP address to scan:")
max_port = st.slider("Maximum port to scan", 1, 65535, 1000)

if st.button("Scan for Vulnerabilities"):
    if target:
        target = extract_domain(target)
        
        if is_valid_domain(target) or is_valid_ip(target):
            with st.spinner("Scanning for vulnerabilities... This may take up to 1 minute."):
                vulnerabilities = perform_vulnerability_scan(target, max_port)
                
                if vulnerabilities:
                    st.subheader("Scan Results")
                    for vuln in vulnerabilities:
                        st.write(f"Port: {vuln['port']}")
                        st.write(f"Service: {vuln['service']}")
                        st.write(f"Banner: {vuln['banner']}")
                        st.write(f"Potential Vulnerabilities: {vuln['potential_vulnerabilities']}")
                        st.write("---")
                    
                    # Get location of the IP and display on map
                    ip = socket.gethostbyname(target)
                    lat, lon = get_ip_location(ip)
                    if lat and lon:
                        st.subheader("Target Location")
                        map_data = pdk.Layer(
                            "ScatterplotLayer",
                            data=[{"position": [lon, lat], "color": [255, 0, 0, 160], "radius": 100}],
                            get_position="position",
                            get_color="color",
                            get_radius="radius",
                        )
                        view_state = pdk.ViewState(latitude=lat, longitude=lon, zoom=4)
                        st.pydeck_chart(pdk.Deck(layers=[map_data], initial_view_state=view_state))
                    else:
                        st.info("Unable to determine the location of the target.")
                else:
                    st.info("No open ports found or unable to complete the scan.")
        else:
            st.error("Invalid domain or IP address. Please enter a valid target.")
    else:
        st.error("Please enter a domain or IP address to scan.")

st.sidebar.warning("Note: This tool provides a basic vulnerability assessment. Always ensure you have permission to scan systems and use this information responsibly.")