import streamlit as st
import socket
import re
import concurrent.futures
from urllib.parse import urlparse
import subprocess
import json

def is_valid_domain(domain):
    pattern = r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$"
    return re.match(pattern, domain) is not None

def is_valid_ip(ip):
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

def extract_domain(url):
    parsed_url = urlparse(url)
    domain = parsed_url.netloc or parsed_url.path
    domain = domain.split(':')[0]  # Remove port if present
    return domain.lower()

def check_port(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, port))
    sock.close()
    return port if result == 0 else None

def get_service_name(port):
    common_ports = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
        110: "POP3", 143: "IMAP", 443: "HTTPS", 445: "SMB", 3306: "MySQL",
        3389: "RDP", 5432: "PostgreSQL", 8080: "HTTP-Proxy"
    }
    return common_ports.get(port, "Unknown")

def perform_vulnerability_scan(target):
    try:
        ip = socket.gethostbyname(target)
    except socket.gaierror:
        st.error(f"Unable to resolve hostname: {target}")
        return None

    common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3306, 3389, 5432, 8080]
    open_ports = []

    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_to_port = {executor.submit(check_port, ip, port): port for port in common_ports}
        for future in concurrent.futures.as_completed(future_to_port):
            port = future.result()
            if port:
                open_ports.append(port)

    vulnerabilities = []
    for port in open_ports:
        service = get_service_name(port)
        vulnerabilities.append({
            'port': port,
            'service': service,
            'potential_vulnerabilities': f"Open {service} port may be vulnerable if not properly secured."
        })

    return vulnerabilities

def check_dependencies():
    try:
        result = subprocess.run(['safety', 'check', '--json'], capture_output=True, text=True)
        vulnerabilities = json.loads(result.stdout)
        return vulnerabilities
    except subprocess.CalledProcessError as e:
        st.error(f"Error running safety check: {e}")
        return None
    except json.JSONDecodeError:
        st.error("Error parsing safety check results")
        return None

st.title("Vulnerability Scanner")

st.warning("⚠️ This tool is for educational purposes only. Do not use on systems you don't own or have explicit permission to test.")

scan_type = st.radio("Select scan type:", ["Network Scan", "Dependency Check"])

if scan_type == "Network Scan":
    target = st.text_input("Enter a domain or IP address to scan:")

    if st.button("Scan for Vulnerabilities"):
        if target:
            target = extract_domain(target)
            
            if is_valid_domain(target) or is_valid_ip(target):
                with st.spinner("Scanning for vulnerabilities... This may take a few minutes."):
                    vulnerabilities = perform_vulnerability_scan(target)
                    
                    if vulnerabilities:
                        st.subheader("Scan Results")
                        for vuln in vulnerabilities:
                            st.write(f"Port: {vuln['port']}")
                            st.write(f"Service: {vuln['service']}")
                            st.write(f"Potential Vulnerabilities: {vuln['potential_vulnerabilities']}")
                            st.write("---")
                    else:
                        st.info("No open ports found or unable to complete the scan.")
            else:
                st.error("Invalid domain or IP address. Please enter a valid target.")
        else:
            st.error("Please enter a domain or IP address to scan.")

elif scan_type == "Dependency Check":
    if st.button("Check Dependencies"):
        with st.spinner("Checking dependencies for vulnerabilities..."):
            vulnerabilities = check_dependencies()
            if vulnerabilities:
                st.subheader("Vulnerability Report")
                for vuln in vulnerabilities:
                    st.write(f"Package: {vuln['package_name']}")
                    st.write(f"Installed Version: {vuln['installed_version']}")
                    st.write(f"Vulnerable Versions: {vuln['vulnerable_spec']}")
                    st.write(f"CVE: {vuln['vulnerability_id']}")
                    st.write(f"Severity: {vuln['severity']}")
                    st.write(f"Advisory: {vuln['advisory']}")
                    st.write("---")
            else:
                st.info("No vulnerabilities found in dependencies.")

st.sidebar.warning("Note: This tool provides a basic vulnerability assessment. Always ensure you have permission to scan systems and use this information responsibly.")